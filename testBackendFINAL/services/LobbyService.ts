import { FriendlyPlayerT, lobbyRepository, LobbyT, LobbyUserT, RankedPlayerT, TournamentPlayerT } from "../Repositories/LobbyRepository.js";
import { MatchSettingsT } from "../Repositories/MatchRepository.js";
import { socketRepository } from "../Repositories/SocketRepository.js";
import { userRepository } from "../Repositories/UserRepository.js";
import { friendlyService } from "./FriendlyService.js";
import { rankedService } from "./RankedService.js";
import { socketService } from "./SocketService.js";
import { tournamentService } from "./TournamentService.js";

class LobbyService {

    addUser(lobbyID: number, userID: number) {
        const lobby = lobbyRepository.getLobbyByID(lobbyID);
        const userInfo = userRepository.getUserByID(userID);
        const user = {
            id: userInfo.id,
            username: userInfo.username,
            spriteID: userInfo.spriteID,
            rating: userInfo.rating,
            ready: false,
            player: null
        }
        lobby.users.push(user);

        if (lobby.users.length > 1) {
            console.log(lobby.users.length)
            socketService.broadcastToLobby(lobbyID, "addLobbyUser", { user: user })
        }
    }

    removeUser(lobbyID: number, userID: number) {
        const lobby = lobbyRepository.getLobbyByID(lobbyID);
        lobby.users = lobby.users.filter(user => user.id !== userID);
        socketService.broadcastToLobby(lobbyID, "removeLobbyUser", { userID: userID })
    }

    updateSettings(lobbyID: number, senderID: number, newSettings: MatchSettingsT) {
        const lobby = lobbyRepository.getLobbyByID(lobbyID);
        if (lobby.hostID !== senderID) { console.log("Somehow a non host managed to send a settings change request!!")}
        const updateUsers = lobby.matchSettings.map !== newSettings.map && lobby.type !== "tournament"
        lobby.matchSettings = newSettings;

        let users: LobbyUserT[] | null = null;
        if (updateUsers) {
            lobby.users.forEach(user => {
                user.player = null;
                user.ready = false
            })
            users = lobby.users;
        }

        socketService.broadcastToLobby(lobbyID, "updateSettings", {
            settings: newSettings,
            users: users
        })
    }

    updateUserReadinesss(lobbyID: number, userID: number, ready: boolean) {
        const user = lobbyRepository.getLobbyUserByID(lobbyID, userID);
        if (!user.player) {
            socketService.broadcastToUsers([userID], "actionBlock", { blockType: "setReadyWithoutJoining" })
            return;
        }
        user.ready = ready

        socketService.broadcastToLobby(lobbyID, "updateReadiness", {
            userID: userID,
            ready: ready
        })
    }

    addFriendlyPlayer(lobbyID: number, userID: number, player: FriendlyPlayerT) {
        const user = lobbyRepository.getLobbyUserByID(lobbyID, userID);
        //id comes as -1, because is only setting that must be generated by backend
        player.id = this._currentID++;
        if (!user.player) {
            user.player = [player]
        } else {
            (user.player as FriendlyPlayerT[]).push(player)
        }

        socketService.broadcastToLobby(lobbyID, "addFriendlyPlayer", {
            userID: userID,
            player: player
        })
    }

    removeFriendlyPlayer(lobbyID: number, userID: number, playerID: number) {
        const user = lobbyRepository.getLobbyUserByID(lobbyID, userID);
        user.player = (user.player as FriendlyPlayerT[]).filter(player => player.id !== playerID)
        if ((user.player as FriendlyPlayerT[]).length === 0) { user.player = null}

        socketService.broadcastToLobby(lobbyID, "removeFriendlyPlayer", {
            playerID: playerID
        })

        user.ready = false;
        socketService.broadcastToLobby(lobbyID, "updateReadiness", {
            userID: userID,
            ready: false
        })
    }

    addRankedPlayer(lobbyID: number, userID: number, player: RankedPlayerT) {
        const user = lobbyRepository.getLobbyUserByID(lobbyID, userID);
        user.player = player;

        socketService.broadcastToLobby(lobbyID, "addRankedPlayer", {
            userID: userID,
            player: player
        })
    }

    removeRankedPlayer(lobbyID: number, userID: number) {
        const user = lobbyRepository.getLobbyUserByID(lobbyID, userID);
        user.player = null;
        socketService.broadcastToLobby(lobbyID, "removeRankedPlayer", {
            userID: userID
        })

        user.ready = false;
        socketService.broadcastToLobby(lobbyID, "updateReadiness", {
            userID: userID,
            ready: false
        })
    }

    addTournamentPlayer(lobbyID: number, userID: number) {
        const user = lobbyRepository.getLobbyUserByID(lobbyID, userID);
        user.player = {} as TournamentPlayerT
        
        socketService.broadcastToLobby(lobbyID, "addTournamentPlayer", {
            userID: userID,
        })
    }

    removeTournamentPlayer(lobbyID: number, userID: number) {
        const user = lobbyRepository.getLobbyUserByID(lobbyID, userID);
        
        user.player = null;
        socketService.broadcastToLobby(lobbyID, "removeTournamentPlayer", {
            userID: userID
        })

        user.ready = false;
        socketService.broadcastToLobby(lobbyID, "updateReadiness", {
            userID: userID,
            ready: false
        })
    }

    start(lobbyID: number, senderID: number) {
        const lobby = lobbyRepository.getLobbyByID(lobbyID);
        if (lobby.hostID !== senderID) {
            console.log(`Somehow userID ${senderID} is not host and tried to start the game!`)
            return ;
        }

        if (!this._isEveryoneReady(lobby.users)) {
            socketService.broadcastToUsers([senderID], "actionBlock", { blockType: "notEveryoneReady" })
            return;
        }

        switch (lobby.type) {
            case "friendly":
                friendlyService.start(lobby, senderID);
                break;
            case "ranked":
                rankedService.start(lobby, senderID);
                break;
            case "tournament":
                tournamentService.start(lobby, senderID);
                break;
            default:
                throw Error("lobby type not recognized!");
        }
    }

    returnToLobby(lobbyID: number) {
        const lobby = lobbyRepository.getLobbyByID(lobbyID);
        lobby.users.forEach(user => {
            user.player = null;
            user.ready = false;
        })
        socketService.broadcastToLobby(lobbyID, "returnToLobby", { lobby: lobby })
    }

    private _currentID: number = 0; //Necessary to tag the friendly players

    private _isEveryoneReady(lobbyUsers: LobbyUserT[]): boolean {
        return lobbyUsers.find(user => (user.player && !user.ready)) ? false : true
    }
}

export const lobbyService = new LobbyService()