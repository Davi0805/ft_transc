

/* import { FriendlyPlayerT, lobbyRepository, LobbyT, LobbyUserT, RankedPlayerT, TournamentPlayerT } from "../Repositories/LobbyRepository.js";
import { MatchSettingsT } from "../Repositories/MatchRepository.js";
import { tournamentRepository } from "../Repositories/TournamentRepository.js";
import { userRepository } from "../Repositories/UserRepository.js";
import { friendlyService } from "./FriendlyService.js";
import { rankedService } from "./RankedService.js";
import { socketService } from "./SocketService.js";
import { tournamentService } from "./TournamentService.js"; */

import lobbyRepository from "../../Adapters/Outbound/LobbyRepository.js";

class LobbyService {
    getAllLobbies() {
        return lobbyRepository.getAllLobbies();
    }

    /* addUser(lobbyID: number, userID: number) {
        const lobby = lobbyRepository.getLobbyByID(lobbyID);
        const userInfo = userRepository.getUserByID(userID);
        const user = {
            id: userInfo.id,
            username: userInfo.username,
            spriteID: userInfo.spriteID,
            rating: userInfo.rating,
            ready: false,
            player: null
        }
        //Broadcast before adding, so the user that just arrived does NOT get the message
        //This user will receive the entire lobby info instead, which already includes him/her
        socketService.broadcastToLobby(lobbyID, "addLobbyUser", { user: user })
        lobby.users.push(user);
    }

    removeUser(lobbyID: number, userID: number) {
        const lobby = lobbyRepository.getLobbyByID(lobbyID);
        lobby.users = lobby.users.filter(user => user.id !== userID);
        socketService.broadcastToLobby(lobbyID, "removeLobbyUser", { userID: userID })
    }

    updateSettings(lobbyID: number, senderID: number, newSettings: MatchSettingsT) {
        const lobby = lobbyRepository.getLobbyByID(lobbyID);
        if (lobby.hostID !== senderID) {
            console.log("Somehow a non host managed to send a settings change request! It will be ignored.");
            return;
        }

        //It should remove all users from slots in case the map change messes up with which slots are available!
        const updateUsers = lobby.matchSettings.map !== newSettings.map && lobby.type !== "tournament"
        lobby.matchSettings = newSettings;

        let users: LobbyUserT[] | null = null;
        if (updateUsers) {
            lobby.users.forEach(user => {
                user.player = null;
                user.ready = false
            })
            users = lobby.users;
        }

        socketService.broadcastToLobby(lobbyID, "updateSettings", {
            settings: newSettings,
            users: users
        })
        //No need to broadcast readiness change, as the users themselves will be rewritten by the dto sent in updateSettings, which includes ready:false for all
    }

    updateUserReadinesss(lobbyID: number, userID: number, ready: boolean) {
        const user = lobbyRepository.getLobbyUserByID(lobbyID, userID);
        if (!user.player) {
            socketService.broadcastToUsers([userID], "actionBlock", { reason: "setReadyWithoutJoining" })
            return;
        }
        user.ready = ready

        //Currently, broadcasting to all users is actually not necessary, as the frontend does not need to know which users are ready.
        //It is working though, so I will leave it here, because if we want to show that info eventually, it is already set up
        socketService.broadcastToLobby(lobbyID, "updateReadiness", {
            userID: userID,
            ready: ready
        })
    }

    addFriendlyPlayer(lobbyID: number, userID: number, player: FriendlyPlayerT) {
        const user = lobbyRepository.getLobbyUserByID(lobbyID, userID);
        //id comes as -1, because is only setting that must be generated by backend
        player.id = this._currentID++;
        //This distinction is important to make because, for unification purposes, if a user is not participating, player is null and not an empty array
        if (!user.player) {
            user.player = [player]
        } else {
            (user.player as FriendlyPlayerT[]).push(player)
        }

        socketService.broadcastToLobby(lobbyID, "addFriendlyPlayer", {
            userID: userID,
            player: player
        })
    }

    removeFriendlyPlayer(lobbyID: number, userID: number, playerID: number) {
        const user = lobbyRepository.getLobbyUserByID(lobbyID, userID);
        user.player = (user.player as FriendlyPlayerT[]).filter(player => player.id !== playerID)
        if ((user.player as FriendlyPlayerT[]).length === 0) { user.player = null}

        socketService.broadcastToLobby(lobbyID, "removeFriendlyPlayer", {
            playerID: playerID
        })

        //For all removes, the user must become not ready
        user.ready = false;
        socketService.broadcastToLobby(lobbyID, "updateReadiness", {
            userID: userID,
            ready: false
        })
    }

    addRankedPlayer(lobbyID: number, userID: number, player: RankedPlayerT) {
        const user = lobbyRepository.getLobbyUserByID(lobbyID, userID);
        user.player = player;

        socketService.broadcastToLobby(lobbyID, "addRankedPlayer", {
            userID: userID,
            player: player
        })
    }

    removeRankedPlayer(lobbyID: number, userID: number) {
        const user = lobbyRepository.getLobbyUserByID(lobbyID, userID);
        user.player = null;
        socketService.broadcastToLobby(lobbyID, "removeRankedPlayer", {
            userID: userID
        })

        user.ready = false;
        socketService.broadcastToLobby(lobbyID, "updateReadiness", {
            userID: userID,
            ready: false
        })
    }

    addTournamentPlayer(lobbyID: number, userID: number) {
        const lobby = lobbyRepository.getLobbyByID(lobbyID);
        const participantsAmount = lobby.users.filter(user => user.player != null).length;

        if (participantsAmount < tournamentRepository.MAX_PARTICIPANTS) {
            const user = lobbyRepository.getLobbyUserByID(lobbyID, userID);
            user.player = {} as TournamentPlayerT
            socketService.broadcastToLobby(lobbyID, "addTournamentPlayer", {
                userID: userID,
            })
        } else {
            socketService.broadcastToUsers([userID], "actionBlock", { reason: "tooManyPlayersInTournament" })
        }
        
    }

    removeTournamentPlayer(lobbyID: number, userID: number) {
        const user = lobbyRepository.getLobbyUserByID(lobbyID, userID);
        
        user.player = null;
        socketService.broadcastToLobby(lobbyID, "removeTournamentPlayer", {
            userID: userID
        })

        user.ready = false;
        socketService.broadcastToLobby(lobbyID, "updateReadiness", {
            userID: userID,
            ready: false
        })
    }

    start(lobbyID: number, senderID: number) {
        const lobby = lobbyRepository.getLobbyByID(lobbyID);
        if (lobby.hostID !== senderID) {
            console.log(`Somehow userID ${senderID} is not host and tried to start the game!`)
            return ;
        }

        if (!this._isEveryoneReady(lobby.users)) {
            socketService.broadcastToUsers([senderID], "actionBlock", { reason: "notEveryoneReady" })
            return;
        }

        //Lobby's job is done. Delegate work to the corresponding service
        switch (lobby.type) {
            case "friendly":
                friendlyService.start(lobby, senderID);
                break;
            case "ranked":
                rankedService.start(lobby, senderID);
                break;
            case "tournament":
                tournamentService.start(lobby, senderID);
                break;
            default:
                throw Error("lobby type not recognized!");
        }
    }

    returnToLobby(lobbyID: number) {
        const lobby = lobbyRepository.getLobbyByID(lobbyID);
        lobby.users.forEach(user => {
            user.player = null;
            user.ready = false;
        })
        socketService.broadcastToLobby(lobbyID, "returnToLobby", { lobby: lobby })
    }

    private _currentID: number = 0; //Necessary to tag the friendly players

    private _isEveryoneReady(lobbyUsers: LobbyUserT[]): boolean {
        return lobbyUsers.find(user => (user.player && !user.ready)) ? false : true
    } */
}

const lobbyService = new LobbyService();
export default lobbyService;